## 方法

- **语句的集合** -> 执行某项功能 (最主要的方法就是我们一开始都使用的main方法)
  - 方法是解决一类问题的步骤的有序组合
  - 包含在类或对象中
  - 在程序中创建，在其他地方引用
- 方法头 + 方法体
- 类似于功能函数

Java 是值传递


|值传递|引用传递|
|--|--|
|在调用函数时将实际参数**复制**一份传给函数的形参中，那么在函数中如果对函数进行修改，是**不会影响**实际参数 (传值)|调用函数的时候将实际参数直接传给函数，那么函数在对函数修改的时候，会**影响**到实际参数的值(可以试着传个对象)|



## 重载

- 一个类中具有相同函数名称，但是参数不一样的函数

- 规则如下:

  - 方法名相同

  - 参数列表**必须不同**(个数不同、类型不同、参数排列顺序不同等...)

  - 方法返回类型可同可不同

    

- 可变参数 例如 数据类型... 变量名 。每个方法只能指定一个可变参数，只能作为最后一个参数 (其实类似于数组)

  ```java
  public void test(int... i)
  ```




## 二维数组

```java
/*
二维数组相当于一维数组的嵌套、
arr[0][0] -> {1,2}当中的1
arr[0][1] -> {1,2}当中的2
...
以此类推
 */
int[][] arr = new int[][]{{1,2},{3,4},{5,6}};
System.out.println(arr.length) //输出 3 
System.out.println(arr[0].length) // 输出 2
```



## Arrays

```java
   int[] a = {1,2,3,4,213213,321321,1231,451122};
   System.out.println(a); // 这样输出的是一个对象
   System.out.println(Arrays.toString(a)); //打印数组
```



## 冒泡排序

```java
 public static int[] sort(int[] array){
       int temp = 0;
       // 外层循环，判断进行多少次比较
       for(int i=0;i<array.length - 1; i++){
           boolean flag = false; // 没排过序
           for(int j = 0; j<array.length-i-1;j++){
               if(array[j] >array[j+1] && !flag){
                   temp = array[j+1];
                   array[j+1] = array[j];
                   array[j] = temp;
                   flag = true; // 局部已排好序
               }
           }
       }
       return array;
   }
```



## 静态/ 非静态

静态 static 与类一起加载(只执行一次) 能够直接调用

非静态 没有static 需要通过构造对象来调用属性、方法(功能)



## 构造器

1. 与类名相同
2. 没有返回值



## 封装

1. 只能通过方法(接口)进行调用设置属性

2. 这样更好的维护，提高开发效率

   

## 继承

1. 关键字 : extends。子类(派生类) extends 父类

2. 子类继承了父类，子类就会拥有父类的全部方法

3. Java中, 所有类都默认继承object类

4. 只支持单继承 一个子类只能继承一个父类 一个父类可以有多个子类

5. this 指的是当前的属性值 super指的是调用父类的方法 (调用父类的构造器 super() 必须放在第一行)

6. 方法的重写 子类重写了父类的(public)方法(非静态 -> 非static)

   - @Override

   - 方法名相同

   - 参数列表相同

     

## 多态

- 方法的多态, 属性没有多态性

1. 一个方法能够有不同的行为 

2. 子类重写父类方法

3. 父亲引用指向子类对象

4. A instanceof B A是否是B的子类 A与B之间是否有父子关系

5. 子类转换为父类 向上转型

6. 父类转换为子类 向下转型 强制转换

   

静态导入包 import static java.lang.Math.random; 即可直接调用random()

final修饰的类不可被继承
final定义的属性为常量